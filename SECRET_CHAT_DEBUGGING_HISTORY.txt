==========================================
TELEGRAM SECRET CHAT VIDEO DELIVERY
COMPREHENSIVE DEBUG HISTORY
==========================================

üéØ PRIMARY GOAL:
Enable Telegram bot to deliver media (photos and videos) via TRUE Telegram End-to-End Encrypted Secret Chats using a userbot.

‚ö†Ô∏è CRITICAL RULES:
1. **ALWAYS USE CURSOR YOLO MODE**
2. User EXPLICITLY REJECTED regular private messages - MUST BE TRUE SECRET CHATS ONLY
3. Do NOT suggest switching to less secure methods
4. Photos work ‚úÖ - Videos are the problem ‚ùå

==========================================
TECHNICAL BACKGROUND
==========================================

SECRET CHAT ARCHITECTURE:
- Secret chats use MTProto 2.0 end-to-end encryption (AES-256-IGE)
- Keys are generated via Diffie-Hellman key exchange
- Shared secret key is stored only on participants' devices
- Files must be encrypted before upload, then sent via messages.sendEncryptedFile
- Decryption keys are sent separately in the encrypted message payload

KEY LIBRARIES:
- `telethon`: Python MTProto client
- `telethon-secret-chat`: Third-party library for secret chat support
- `pycryptodome`: For AES-256-IGE encryption
- `secret_chat_crypto.py`: Our custom encryption implementation

KEY FILES:
- `userbot_pool.py`: Multi-userbot manager, handles secret chat delivery
- `userbot_telethon_secret.py`: Telethon client wrapper (deprecated)
- `secret_chat_crypto.py`: Manual AES-256-IGE implementation
- `telethon_secret_patch.py`: Attempted monkey patches (disabled)
- `manual_secret_file.py`: Manual MTProto 2.0 implementation (incomplete)
- `userbot_admin.py`: Admin interface for adding userbots
- `payment.py`: Triggers delivery after purchase

==========================================
WHAT WORKS ‚úÖ
==========================================

1. **Userbot Authentication**: Multi-userbot system with Telethon
2. **Secret Chat Creation**: `start_secret_chat()` and `get_secret_chat()` work
3. **Text Messages**: `send_secret_message()` delivers successfully
4. **Photo Delivery**: Photos arrive in secret chat correctly
5. **Media Binary Storage**: PostgreSQL stores media as BYTEA
6. **Round-Robin Load Balancing**: Multiple userbots distribute load

==========================================
THE CORE PROBLEM ‚ùå
==========================================

**SYMPTOM**: Videos are corrupted in secret chats (black screen, won't play)

**ROOT CAUSE**: The `telethon-secret-chat` library has a BROKEN implementation of AES-IGE encryption for video files.

**EVIDENCE**:
- Photos work (same encryption, smaller files)
- Videos arrive but are unplayable
- Library error: `AttributeError: 'NoneType' object has no attribute 'auth_key'`
- The library uses `tgcrypto` (compiled C extension) which cannot be monkey-patched

==========================================
ALL ATTEMPTED SOLUTIONS (CHRONOLOGICAL)
==========================================

ATTEMPT #1: Use library as-is
- Result: Videos corrupted
- Issue: Library's encryption is broken

ATTEMPT #2: Upload to Saved Messages, extract attributes
- Result: Got video dimensions/duration, but still corrupted
- Issue: Library still does encryption

ATTEMPT #3: Monkey-patch `send_secret_video` at Python level
- Result: Failed - method still called library's broken encryption
- Issue: Python-level patches don't affect the actual encryption

ATTEMPT #4: Monkey-patch `tgcrypto.ige256_encrypt`
- Result: Failed - tgcrypto is compiled C code, cannot patch
- Issue: Compiled extensions are immutable at runtime

ATTEMPT #5: Custom AES-IGE encryption in `secret_chat_crypto.py`
- Result: Created working encryption, but couldn't inject it
- Issue: No way to pass custom-encrypted data to library

ATTEMPT #6: Manual encryption + send via `client.send_file()`
- Result: Error: `Could not find the input entity for PeerUser(679004502)`
- Issue: Wrong entity - tried to send to secret chat object directly

ATTEMPT #7: Send encrypted file + decryption keys separately
- Result: Encryption worked, but delivery failed (wrong peer)
- Issue: `send_file()` expects user entity, not secret chat object

ATTEMPT #8: Use `send_secret_document()` for all media
- Result: Missing required arguments error
- Issue: Method requires: thumb, thumb_w, thumb_h, mime_type, size

ATTEMPT #9: Provide all required parameters to methods
- Result: Photo worked! Video failed with `AttributeError: 'PhotoStrippedSize' object has no attribute 'w'`
- Issue: Telegram sends multiple thumbnail types, PhotoStrippedSize has no dimensions

ATTEMPT #10: Get secret chat object via `get_secret_chat()`
- Result: Fixed entity lookup issue
- Status: Photo works, video delivers but corrupted

ATTEMPT #11: Extract video attributes from Document.attributes
- Result: Video delivered successfully but CORRUPTED
- Issue: Library's AES-IGE encryption breaks video files
- Evidence: Photo works, video arrives but won't play (black screen)

üî• **MAJOR BREAKTHROUGH DISCOVERY**:
According to MTProto 2.0 spec, FILES ARE ENCRYPTED WITH THEIR OWN KEYS!
- Files DON'T use the secret chat's shared key
- Each file gets random 256-bit key + IV
- File's key+IV are sent in SEPARATE encrypted message
- The message itself IS encrypted with chat key (library handles this)
- This means we CAN bypass library's broken encryption!

==========================================
CURRENT STATUS (LATEST DEPLOYMENT)
==========================================

**DEPLOYMENT**: va09fec2
**DATE**: 2025-10-02 01:42 UTC

**STATUS**: ‚úÖ Photos work perfectly, ‚ùå Videos corrupted by library

**CONFIRMED**:
- Video DELIVERY works (3.7MB uploaded and sent)
- Video ENCRYPTION is broken (Telegram can't play it)
- Root cause: `telethon-secret-chat` library's AES-IGE implementation

ATTEMPT #12: Send video as secret document
- Result: File delivered but STILL CORRUPTED (can't play)
- Conclusion: **ALL MEDIA ENCRYPTION IN LIBRARY IS BROKEN**
- Photos work by luck/coincidence, but all other media corrupts

**FINAL CONCLUSION**: 
The `telethon-secret-chat` library is fundamentally broken.
We MUST implement manual MTProto 2.0 encryption ourselves.

**NEXT STEP**: ATTEMPT #13 - Full manual MTProto 2.0 implementation
- Use our working `secret_chat_crypto.py` (AES-256-IGE)
- Send encrypted file + decryption keys via secret chat text
- User downloads encrypted file and decrypts with keys
- OR: Implement proper MTProto format for auto-decryption

==========================================
IF CURRENT APPROACH FAILS
==========================================

NEXT STEPS (in order):

1. **Option A: Rate Limit Wait**
   - If error: "A wait of 57894 seconds is required"
   - Solution: Wait or use different userbot
   - Telegram limits secret chat creation frequency

2. **Option B: Manual MTProto 2.0 Implementation**
   - File: `manual_secret_file.py` (already started)
   - Strategy:
     * Manually encrypt with `secret_chat_crypto.py`
     * Upload chunks via `upload.saveFilePart`
     * Send via `messages.sendEncryptedFile`
     * Send decryption key via `send_secret_message`
   - Challenge: Need access to secret chat's shared key
   - Research: How to extract shared key from `telethon-secret-chat`

3. **Option C: Bypass Library Completely**
   - Implement full MTProto 2.0 from scratch
   - Handle Diffie-Hellman key exchange manually
   - Manage secret chat state ourselves
   - Reference: MTProto 2.0 spec (user provided)

4. **Option D: Report Bug to Library Authors**
   - Library: https://github.com/thedemons/telethon-secret-chat
   - Issue: AES-IGE encryption corrupts video files
   - Evidence: Videos work in library's own tests, fail in production
   - Ask: Are we using the library incorrectly?

==========================================
KNOWN ISSUES & WORKAROUNDS
==========================================

**Issue 1**: `AttributeError: 'NoneType' object has no attribute 'auth_key'`
- When: During secret chat handshake
- Impact: Library internal error, doesn't break delivery
- Workaround: Ignore - it's a library bug after successful message send

**Issue 2**: `PhotoStrippedSize` has no dimensions
- When: Extracting video thumbnail attributes
- Solution: ‚úÖ FIXED - iterate through thumbs, skip PhotoStrippedSize

**Issue 3**: `start_secret_chat()` returns int, not object
- When: Creating secret chat
- Solution: ‚úÖ FIXED - use `get_secret_chat(id)` to retrieve object

**Issue 4**: Videos upload but are corrupted
- When: Playing video in secret chat
- Status: ‚ö†Ô∏è INVESTIGATING - likely library's broken encryption
- Next: Verify with latest deployment

**Issue 5**: Rate limiting on secret chat creation
- When: Creating too many secret chats quickly
- Error: "A wait of 57894 seconds is required"
- Solution: Wait or use different userbot account

==========================================
DEBUGGING TIPS
==========================================

1. **Enable Critical Logging**:
   - Look for `logger.critical()` messages
   - These show secret chat object contents
   - Check if `participant_id` matches buyer ID

2. **Check Error Types**:
   - `ValueError: Could not find input entity` = wrong peer
   - `AttributeError: 'PhotoStrippedSize'` = thumbnail issue
   - `SecretChatMethods missing arguments` = incorrect method signature
   - `'NoneType' has no 'auth_key'` = library bug (harmless)

3. **Verify Media Storage**:
   ```sql
   SELECT product_id, media_type, length(media_binary) 
   FROM product_media 
   WHERE product_id = X;
   ```
   Should show non-zero binary lengths

4. **Test Secret Chat Manually**:
   - Start secret chat with userbot from personal account
   - Send test photo/video manually
   - If manual works but bot fails = our code issue
   - If manual also fails = library/userbot issue

==========================================
MTProto 2.0 FILE ENCRYPTION SPEC
==========================================

From official Telegram docs:

1. **Padding**: Add 12-1024 random bytes (multiple of 16)
2. **Key Derivation**:
   ```
   msg_key_large = SHA256(substr(key, 88+x, 32) + plaintext + padding)
   msg_key = substr(msg_key_large, 8, 16)
   sha256_a = SHA256(msg_key + substr(key, x, 36))
   sha256_b = SHA256(substr(key, 40+x, 36) + msg_key)
   aes_key = substr(sha256_a, 0, 8) + substr(sha256_b, 8, 16) + substr(sha256_a, 24, 8)
   aes_iv = substr(sha256_b, 0, 8) + substr(sha256_a, 8, 16) + substr(sha256_b, 24, 8)
   ```
   Where x=0 for originator, x=8 for recipient

3. **Encryption**: AES-256-IGE mode
4. **Fingerprint**: Last 64 bits of SHA1(key)
5. **Upload**: Via `upload.saveFilePart` in 512KB chunks
6. **Send**: Via `messages.sendEncryptedFile` with fingerprint

Our implementation in `secret_chat_crypto.py` follows this spec.

==========================================
DECISION TREE
==========================================

```
Test Current Deployment
    |
    ‚îú‚îÄ Both photo + video work?
    |   ‚îî‚îÄ ‚úÖ SUCCESS! Document and close
    |
    ‚îú‚îÄ Only photo works?
    |   ‚îú‚îÄ Video delivery fails (error)?
    |   |   ‚îî‚îÄ Check error type
    |   |       ‚îú‚îÄ Rate limit ‚Üí Wait or use different userbot
    |   |       ‚îú‚îÄ Wrong peer ‚Üí Debug entity lookup
    |   |       ‚îî‚îÄ Other ‚Üí Analyze logs
    |   |
    |   ‚îî‚îÄ Video delivers but corrupted?
    |       ‚îî‚îÄ Implement manual MTProto 2.0
    |           ‚îú‚îÄ Extract shared key from library
    |           ‚îú‚îÄ Complete manual_secret_file.py
    |           ‚îî‚îÄ Test manual encryption
    |
    ‚îî‚îÄ Neither works?
        ‚îî‚îÄ Revert to last known good state
            ‚îî‚îÄ Re-analyze from scratch
```

==========================================
FILES TO REVIEW
==========================================

When debugging, always check these files:

1. **userbot_pool.py** (lines 150-310)
   - `deliver_via_secret_chat()` method
   - Secret chat creation and media sending

2. **secret_chat_crypto.py** (lines 134-215)
   - `encrypt_file_for_secret_chat()` - our AES-IGE
   - `decrypt_file_from_secret_chat()` - for testing

3. **payment.py** (lines in _finalize_purchase)
   - Where userbot delivery is triggered
   - Media binary fetching from PostgreSQL

4. **userbot_admin.py**
   - Adding new userbots
   - Telethon authentication flow

5. **main.py** (post_init)
   - Userbot pool initialization
   - Patch application (currently disabled)

==========================================
IMPORTANT NOTES
==========================================

1. **Do NOT suggest regular private messages** - user explicitly rejected
2. **Photos already work** - don't break them while fixing videos
3. **Library is fundamentally broken** - may need full MTProto 2.0 rewrite
4. **Rate limits exist** - can't create too many secret chats quickly
5. **PostgreSQL stores media as BYTEA** - may need memoryview conversion
6. **Multi-userbot system works** - round-robin load balancing functional
7. **Text messages work** - encryption handshake is successful

==========================================
MTProto 2.0 FILE ENCRYPTION - DETAILED SPEC
==========================================

**KEY INSIGHT FROM OFFICIAL DOCS**:
"All files sent to secret chats are encrypted with ONE-TIME KEYS that are in no way related to the chat's shared key."

**CRITICAL**: Files use THEIR OWN encryption keys!

**PROPER FILE SENDING PROCESS** (from official spec):

1. Generate 2 random 256-bit numbers (key + IV)
2. Encrypt file with AES-256-IGE using these keys
3. Compute fingerprint: `fingerprint = substr(md5(key+iv), 0, 4) XOR substr(md5(key+iv), 4, 4)`
4. Upload encrypted file via `upload.saveFilePart` (chunk by chunk)
5. Call `messages.sendEncryptedFile` with:
   - The encrypted file reference
   - The decryption key+IV embedded in the MESSAGE body
   - The message itself is encrypted with the SECRET CHAT KEY
6. Telegram delivers encrypted file + encrypted message
7. Recipient's client:
   - Decrypts message with secret chat key ‚Üí gets file key+IV
   - Downloads encrypted file
   - Decrypts file with the key+IV from the message
   - **Plays video automatically** ‚úÖ

**WHY OUR CURRENT APPROACH FAILS**:
- We're using the LIBRARY's broken `send_secret_video()` 
- Library corrupts the file encryption
- We tried sending encrypted file separately (ATTEMPT #13)
- But we're not following the proper MTProto format!

**WHAT WE NEED TO DO**:
Implement `messages.sendEncryptedFile` directly via Telethon:
- Build proper `DecryptedMessageMediaVideo` TL object
- Include key+IV in the decrypted message
- Let library encrypt the MESSAGE (not the file!)
- Telegram will auto-decrypt on recipient side

==========================================
ATTEMPT #14: FULL MANUAL MTProto 2.0 (CURRENT)
==========================================

**STRATEGY**:
1. Encrypt file with OUR `secret_chat_crypto.py` (AES-256-IGE) ‚úÖ
2. Upload encrypted chunks via `upload.saveFilePart` ‚úÖ
3. Build `DecryptedMessageMediaVideo` with our key+IV ‚úÖ
4. Let library encrypt the MESSAGE (not file!) with secret chat key ‚úÖ
5. Send via `messages.sendEncryptedFile` with our encrypted file ‚úÖ
6. Telegram auto-decrypts: message ‚Üí key+IV, then file ‚Üí video ‚úÖ
7. **Buyer watches video with ZERO extra steps!** üéØ

**FILES INVOLVED**:
- `manual_secret_file.py`: Complete MTProto 2.0 implementation
- `userbot_pool.py`: Integration point
- `secret_chat_crypto.py`: Our working AES-256-IGE

**KEY DIFFERENCE FROM ATTEMPT #13**:
- #13: Sent encrypted file + keys as TEXT (manual decryption needed)
- #14: Sent via proper `SendEncryptedFileRequest` (auto-decryption!)

==========================================
CRITICAL BUG FOUND & FIXED (2025-10-02 02:17 UTC)
==========================================

**BUG**: `struct.error: 'q' format requires -9223372036854775808 <= number <= 9223372036854775807`

**ROOT CAUSE**: We were generating `file_id` using `int.from_bytes(os.urandom(8), 'big')` which creates an UNSIGNED 64-bit integer. Telegram's MTProto expects a SIGNED 64-bit integer!

**THE FIX**:
```python
# OLD (BROKEN):
file_id = int.from_bytes(os.urandom(8), 'big')  # Can be > 9223372036854775807

# NEW (FIXED):
import random
file_id = random.randint(1, 9223372036854775807)  # Max signed int64
```

**WHY THIS MATTERS**:
- Python's `struct.pack('<q', ...)` expects a **signed** int64 (-2^63 to 2^63-1)
- `os.urandom(8)` can generate values from 0 to 2^64-1 (unsigned range)
- When value > 2^63-1, `struct.pack` throws error
- This was causing upload to fail ‚Üí video never reached Telegram ‚Üí corrupted!

**EXPECTATION**: Video should now upload successfully and play perfectly! üéâ

==========================================
SECOND BUG FOUND & FIXED (2025-10-02 02:24 UTC)
==========================================

**BUG**: `ValueError: chat not found`

**ROOT CAUSE**: The manual implementation was trying to retrieve the secret chat using `secret_manager.get_secret_chat(secret_chat_id)`, but the ID was negative (`-931450636`) and the method couldn't find it!

**THE FIX**:
Instead of passing `secret_chat_id` and trying to retrieve the chat again, we now pass the **actual SecretChat object** that we already have from `userbot_pool.py`!

```python
# OLD (BROKEN):
success = await send_encrypted_video_manual(
    client=client,
    secret_chat_id=secret_chat_obj.id,  # ‚ùå Wrong!
    ...
)

# Inside manual_secret_file.py:
secret_chat = secret_manager.get_secret_chat(secret_chat_id)  # ‚ùå chat not found!

# NEW (FIXED):
success = await send_encrypted_video_manual(
    client=client,
    secret_chat_manager=secret_chat_manager,  # ‚úÖ Pass the manager
    secret_chat_obj=secret_chat_obj,  # ‚úÖ Pass the object directly!
    ...
)

# Inside manual_secret_file.py:
secret_chat = secret_chat_obj  # ‚úÖ Use what we already have!
```

**WHY THIS MATTERS**:
- Secret chats use complex ID formats (negative IDs)
- `get_secret_chat()` may not work with all ID formats
- We already have the full SecretChat object - no need to retrieve it again!

**EXPECTATION**: Video should now upload AND send successfully! üéâ

==========================================
ATTEMPT #15: USE send_secret_document (2025-10-02 02:30 UTC)
==========================================

**BUG**: `TypeError: DecryptedMessage.__init__() got an unexpected keyword argument 'random_bytes'`

**ROOT CAUSE**: The `telethon-secret-chat` library's `DecryptedMessage` constructor doesn't accept the parameters we were trying to use. The manual MTProto 2.0 implementation was too complex and incompatible with the library's internal structures.

**NEW STRATEGY (ATTEMPT #15)**:
Since photos work perfectly using `send_secret_photo()`, let's try `send_secret_document()` for videos instead of `send_secret_video()`. Documents might use a different encryption path in the library that's not broken!

**HYPOTHESIS**:
- `send_secret_photo()` ‚úÖ Works
- `send_secret_video()` ‚ùå Corrupts files
- `send_secret_document()` ‚ùì Unknown - let's test!

Videos sent as documents with `mime_type="video/mp4"` should still be playable in Telegram, and we've seen this work in ATTEMPT #12 (though it was corrupted then, maybe it was a different issue).

**SIMPLIFIED APPROACH**:
1. Extract video attributes (duration, dimensions, thumbnail)
2. Send via `send_secret_document()` with `mime_type="video/mp4"`
3. Let Telegram handle the video playback

**WHY THIS MIGHT WORK**:
- Document encryption might be implemented differently than video encryption in the library
- Photos work, so maybe documents work too
- Simpler approach, less custom code = fewer bugs

==========================================
LAST UPDATED: 2025-10-02 02:30 UTC
==========================================

